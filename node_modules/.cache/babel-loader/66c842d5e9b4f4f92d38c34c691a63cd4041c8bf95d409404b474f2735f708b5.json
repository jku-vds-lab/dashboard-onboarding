{"ast":null,"code":"var _jsxFileName = \"/Applications/XAMPP/xamppfiles/htdocs/dashboard-onboarding-ui/src/components/nodesCanvas/index.jsx\",\n  _s = $RefreshSig$();\nimport { useCallback, useState } from \"react\";\nimport ReactFlow, { useNodesState, useEdgesState, Controls, updateEdge, addEdge } from \"reactflow\";\nimport \"reactflow/dist/style.css\";\nimport \"../../assets/css/flow.scss\";\n\n// Node types\nimport BoxNode from \"./nodeTypes/boxNode\";\n//Custom edge\nimport Path from \"./path\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialNodes = [{\n  id: \"node-1\",\n  type: \"boxNode\",\n  position: {\n    x: 0,\n    y: 0\n  },\n  data: {\n    title: \"Dashboard\",\n    type: \"dashboard\"\n  }\n}, {\n  id: \"node-2\",\n  type: \"boxNode\",\n  targetPosition: \"top\",\n  position: {\n    x: 250,\n    y: 0\n  },\n  data: {\n    title: \"Line Chart\",\n    type: \"line-chart\"\n  }\n}, {\n  id: \"node-3\",\n  type: \"boxNode\",\n  targetPosition: \"top\",\n  position: {\n    x: 300,\n    y: 0\n  },\n  data: {\n    title: \"Bar chart\",\n    type: \"bar-chart\"\n  }\n}];\n/** Create edges between nodes if needed*/\nconst initialEdges = [\n  /*{\n      id: \"edge-1\",\n      source: \"node-1\",\n      target: \"node-2\",\n      sourceHandle: \"output-4\",\n      animated: true,\n  },\n  {\n      id: \"edge-3\",\n      source: \"node-1\",\n      target: \"node-3\",\n      sourceHandle: \"output-1\",\n      targetHandle: \"input-1\",\n      type: 'path',\n      data: { n_source: \"1\", n_target: \"3\", h_output: \"1\", h_input: \"1\", color: \"#f1ed00\", class: \"story-1\"},\n      deletable: true,\n  },\n  {\n      id: \"edge-4\",\n      source: \"node-1\",\n      target: \"node-4\",\n      sourceHandle: \"output-2\",\n      targetHandle: \"input-1\",\n      deletable: true,\n      label: \"storyline 2\",\n      labelStyle: {fill: \"white\"},\n      labelBgStyle: {fill: \"#2b2b2b\"},\n  },*/\n];\n\n// we define the nodeTypes outside of the component to prevent re-renderings\n// you could also use useMemo inside the component\nconst nodeTypes = {\n  boxNode: BoxNode\n};\nconst edgeTypes = {\n  path: Path\n};\nfunction NodesCanvas() {\n  _s();\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  /**\n   * Called after end of edge gets dragged to another source or target\n   * @type {function(*=, *=): void}\n   */\n  const onEdgeUpdate = useCallback((oldEdge, newConnection) => {\n    //TODO: create a method to return nodeTarget, inputHandle, sourcetarget, outputHandle\n\n    //reset the color\n    let nodeTarget = document.querySelector('[data-id=\"' + oldEdge.target + '\"]');\n    let inputHandle = nodeTarget.querySelector('[data-handleid=\"' + oldEdge.targetHandle + '\"]');\n    inputHandle.classList.add(\"empty\");\n    //if the new connection is not empty\n    nodeTarget = document.querySelector('[data-id=\"' + newConnection.target + '\"]');\n    inputHandle = nodeTarget.querySelector('[data-handleid=\"' + newConnection.targetHandle + '\"]');\n    if (inputHandle.classList.contains(\"empty\")) {\n      //connect\n    }\n\n    //get path color\n    let nodeSource = document.querySelector('[data-id=\"' + newConnection.source + '\"]');\n    let outputHandle = nodeSource.querySelector('[data-handleid=\"' + newConnection.sourceHandle + '\"]');\n    inputHandle.classList.remove(\"empty\");\n    inputHandle.style.background = outputHandle.style.background;\n    setEdges(els => updateEdge(oldEdge, newConnection, els));\n  }, []);\n  /**\n     * Called when user starts to drag connection line.\n     * We need to assign a color that correspond to the input color, when available.\n     * On the very first node the color is assigned randomly.\n     * @type {(function(*=): void)|*}\n     */\n  const onConnectStart = useCallback(params => {\n    //get an available color from the node\n    params.target.style.background = \"#1ab41e\";\n  }, []);\n  const onConnectEnd = useCallback(params => {\n    //params.target.style.background = \"#1ab41e\"\n  }, []);\n\n  /**\n   *Called when user connects two nodes\n   * @type {function(*=): void}\n   */\n  const onConnect = useCallback(params => {\n    const nodeSource = document.querySelector('[data-id=\"' + params.source + '\"]');\n    const nodeTarget = document.querySelector('[data-id=\"' + params.target + '\"]');\n    let outputHandle = nodeSource.querySelector('[data-handleid=\"' + params.sourceHandle + '\"]');\n    let inputHandle = nodeTarget.querySelector('[data-handleid=\"' + params.targetHandle + '\"]');\n    inputHandle.style.background = outputHandle.style.background;\n    setEdges(els => addEdge(params, els));\n    //finding the path to assign the color\n    //data-testid=\"rf__edge-reactflow__edge-node-1output-3-node-4input-3\n    //var path = document.querySelector('[data-testid=\"rf__edge-reactflow__edge-'+params.source+params.sourceHandle+params.target+params.targetHandle+'\"]');\n  }, []);\n\n  /**\n   * Called, when the node is clicked – do something\n   * @type {(function(): void)|*}\n   */\n  const onNodeClick = useCallback(() => {}, []);\n\n  /**\n   * Called when nodes get deleted. The handles are updated. The narrative trajectory is broken.\n   May be we need to highlight the nodes to indicate the broken linkage\n   * @type {(function(): void)|*}\n   */\n  const onNodesDelete = useCallback(() => {}, []);\n  /**\n   * Called when user clicks an edge. The storyline can be rendered in the presentation editor\n   * @type {(function())|*}\n   */\n  const onEdgeClick = useCallback(() => {}, []);\n  return /*#__PURE__*/_jsxDEV(ReactFlow, {\n    nodes: nodes,\n    edges: edges,\n    onNodesChange: onNodesChange,\n    nodeTypes: nodeTypes,\n    snapToGrid: true,\n    fitView: true\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 190,\n    columnNumber: 9\n  }, this);\n}\n_s(NodesCanvas, \"GNcJ/7qOQBuELTo5XkIIWMKmCL8=\", false, function () {\n  return [useNodesState, useEdgesState];\n});\n_c = NodesCanvas;\nexport default NodesCanvas;\nvar _c;\n$RefreshReg$(_c, \"NodesCanvas\");","map":{"version":3,"names":["useCallback","useState","ReactFlow","useNodesState","useEdgesState","Controls","updateEdge","addEdge","BoxNode","Path","initialNodes","id","type","position","x","y","data","title","targetPosition","initialEdges","nodeTypes","boxNode","edgeTypes","path","NodesCanvas","nodes","setNodes","onNodesChange","edges","setEdges","onEdgesChange","onEdgeUpdate","oldEdge","newConnection","nodeTarget","document","querySelector","target","inputHandle","targetHandle","classList","add","contains","nodeSource","source","outputHandle","sourceHandle","remove","style","background","els","onConnectStart","params","onConnectEnd","onConnect","onNodeClick","onNodesDelete","onEdgeClick"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/dashboard-onboarding-ui/src/components/nodesCanvas/index.jsx"],"sourcesContent":["import {useCallback, useState} from \"react\";\n\nimport ReactFlow, {\n    useNodesState, useEdgesState, Controls, updateEdge, addEdge\n} from \"reactflow\";\n\nimport \"reactflow/dist/style.css\";\nimport \"../../assets/css/flow.scss\";\n\n// Node types\nimport BoxNode from \"./nodeTypes/boxNode\";\n//Custom edge\nimport Path from \"./path\";\n\nconst initialNodes = [\n    {\n        id: \"node-1\",\n        type: \"boxNode\",\n        position: {x: 0, y: 0},\n        data: {title: \"Dashboard\", type: \"dashboard\"},\n    },\n    {\n        id: \"node-2\",\n        type: \"boxNode\",\n        targetPosition: \"top\",\n        position: {x: 250, y: 0},\n        data: {title: \"Line Chart\", type: \"line-chart\"},\n    },\n    {\n        id: \"node-3\",\n        type: \"boxNode\",\n        targetPosition: \"top\",\n        position: {x: 300, y: 0},\n        data: {title: \"Bar chart\", type: \"bar-chart\"},\n    },\n\n];\n/** Create edges between nodes if needed*/\nconst initialEdges = [\n    /*{\n        id: \"edge-1\",\n        source: \"node-1\",\n        target: \"node-2\",\n        sourceHandle: \"output-4\",\n        animated: true,\n    },\n    {\n        id: \"edge-3\",\n        source: \"node-1\",\n        target: \"node-3\",\n        sourceHandle: \"output-1\",\n        targetHandle: \"input-1\",\n        type: 'path',\n        data: { n_source: \"1\", n_target: \"3\", h_output: \"1\", h_input: \"1\", color: \"#f1ed00\", class: \"story-1\"},\n        deletable: true,\n    },\n    {\n        id: \"edge-4\",\n        source: \"node-1\",\n        target: \"node-4\",\n        sourceHandle: \"output-2\",\n        targetHandle: \"input-1\",\n        deletable: true,\n        label: \"storyline 2\",\n        labelStyle: {fill: \"white\"},\n        labelBgStyle: {fill: \"#2b2b2b\"},\n    },*/\n];\n\n\n// we define the nodeTypes outside of the component to prevent re-renderings\n// you could also use useMemo inside the component\nconst nodeTypes = {boxNode: BoxNode};\nconst edgeTypes = {\n    path: Path,\n};\n\nfunction NodesCanvas() {\n    const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n    const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n    /**\n     * Called after end of edge gets dragged to another source or target\n     * @type {function(*=, *=): void}\n     */\n    const onEdgeUpdate = useCallback(\n        (oldEdge, newConnection) => {\n\n            //TODO: create a method to return nodeTarget, inputHandle, sourcetarget, outputHandle\n\n            //reset the color\n            let nodeTarget = document.querySelector('[data-id=\"'+oldEdge.target+'\"]');\n            let inputHandle = nodeTarget.querySelector('[data-handleid=\"'+oldEdge.targetHandle+'\"]');\n            inputHandle.classList.add(\"empty\");\n            //if the new connection is not empty\n            nodeTarget = document.querySelector('[data-id=\"'+newConnection.target+'\"]');\n            inputHandle = nodeTarget.querySelector('[data-handleid=\"'+newConnection.targetHandle+'\"]');\n\n            if(inputHandle.classList.contains(\"empty\")){\n                //connect\n            }\n\n            //get path color\n            let nodeSource = document.querySelector('[data-id=\"'+newConnection.source+'\"]');\n            let outputHandle = nodeSource.querySelector('[data-handleid=\"'+newConnection.sourceHandle+'\"]');\n            inputHandle.classList.remove(\"empty\");\n            inputHandle.style.background=outputHandle.style.background;\n\n\n            setEdges((els) => updateEdge(oldEdge, newConnection, els))},\n        []\n    );\n  /**\n     * Called when user starts to drag connection line.\n     * We need to assign a color that correspond to the input color, when available.\n     * On the very first node the color is assigned randomly.\n     * @type {(function(*=): void)|*}\n     */\n    const onConnectStart = useCallback(\n        (params) => {\n            //get an available color from the node\n            params.target.style.background = \"#1ab41e\";\n\n        },\n        [],\n    );\n\n    const onConnectEnd = useCallback(\n        (params) => {\n            //params.target.style.background = \"#1ab41e\"\n\n        },\n        [],\n    );\n\n\n    /**\n     *Called when user connects two nodes\n     * @type {function(*=): void}\n     */\n    const onConnect = useCallback((params) => {\n\n        const nodeSource = document.querySelector('[data-id=\"'+params.source+'\"]');\n        const nodeTarget = document.querySelector('[data-id=\"'+params.target+'\"]');\n        let outputHandle = nodeSource.querySelector('[data-handleid=\"'+params.sourceHandle+'\"]');\n        let inputHandle = nodeTarget.querySelector('[data-handleid=\"'+params.targetHandle+'\"]');\n        inputHandle.style.background = outputHandle.style.background;\n        setEdges((els) => addEdge(params, els))\n        //finding the path to assign the color\n        //data-testid=\"rf__edge-reactflow__edge-node-1output-3-node-4input-3\n        //var path = document.querySelector('[data-testid=\"rf__edge-reactflow__edge-'+params.source+params.sourceHandle+params.target+params.targetHandle+'\"]');\n\n    }, []);\n\n\n    /**\n     * Called, when the node is clicked – do something\n     * @type {(function(): void)|*}\n     */\n    const onNodeClick = useCallback(\n        () => {\n        },\n        [],\n    );\n\n\n    /**\n     * Called when nodes get deleted. The handles are updated. The narrative trajectory is broken.\n     May be we need to highlight the nodes to indicate the broken linkage\n     * @type {(function(): void)|*}\n     */\n    const onNodesDelete = useCallback(\n        () => {\n\n        },\n        [],\n    );\n    /**\n     * Called when user clicks an edge. The storyline can be rendered in the presentation editor\n     * @type {(function())|*}\n     */\n    const onEdgeClick = useCallback(\n        () => {\n\n        },\n        [],\n    );\n\n\n    return (\n        <ReactFlow\n            nodes={nodes}\n            edges={edges}\n            onNodesChange={onNodesChange}\n            nodeTypes={nodeTypes}\n            snapToGrid\n            fitView\n        />\n    );\n}\n\nexport default NodesCanvas;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}