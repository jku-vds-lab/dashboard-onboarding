{"ast":null,"code":"var _jsxFileName = \"/Applications/XAMPP/xamppfiles/htdocs/dashboard-onboarding-ui/src/components/nodesCanvas/index.jsx\",\n  _s = $RefreshSig$();\nimport { useState, useRef, useCallback } from \"react\";\nimport ReactFlow, { useNodesState, useEdgesState, Controls, updateEdge, addEdge, ReactFlowProvider } from \"reactflow\";\nimport \"reactflow/dist/style.css\";\nimport \"../../assets/css/flow.scss\";\n\n// Node types\nimport BoxNode from \"./nodeTypes/boxNode\";\nimport SimpleNode from \"./nodeTypes/simpleNode\";\n//Custom edge\nimport Path from \"./path\";\nimport Sidebar from '../dashboard/index';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialNodes = [{\n  id: \"node-1\",\n  type: \"simple\",\n  position: {\n    x: 0,\n    y: 70\n  },\n  data: {\n    title: \"Dashboard\",\n    type: \"dashboard\"\n  }\n}, {\n  id: \"node-2\",\n  type: \"simple\",\n  targetPosition: \"top\",\n  position: {\n    x: 120,\n    y: 70\n  },\n  data: {\n    title: \"Line Chart\",\n    type: \"line-chart\"\n  }\n}, {\n  id: 'node-3',\n  data: {\n    label: 'OR'\n  },\n  position: {\n    x: 240,\n    y: 0\n  },\n  className: 'node-group'\n}, {\n  id: \"node-4\",\n  type: \"simple\",\n  targetPosition: \"top\",\n  position: {\n    x: 30,\n    y: 40\n  },\n  data: {\n    title: \"Bar chart\",\n    type: \"bar-chart\"\n  },\n  parentNode: 'node-3'\n}, {\n  id: \"node-5\",\n  type: \"simple\",\n  targetPosition: \"top\",\n  position: {\n    x: 140,\n    y: 40\n  },\n  data: {\n    title: \"Bar chart\",\n    type: \"bar-chart\"\n  },\n  parentNode: 'node-3'\n}, {\n  id: \"node-6\",\n  type: \"simple\",\n  targetPosition: \"top\",\n  position: {\n    x: 30,\n    y: 110\n  },\n  data: {\n    title: \"Dashboard\",\n    type: \"dashboard\"\n  },\n  parentNode: 'node-3'\n}, {\n  id: \"node-7\",\n  type: \"simple\",\n  targetPosition: \"top\",\n  position: {\n    x: 140,\n    y: 110\n  },\n  data: {\n    title: \"Line chart\",\n    type: \"line-chart\"\n  },\n  parentNode: 'node-3'\n}];\n/** Create edges between nodes if needed*/\nconst initialEdges = [\n  /*{\n      id: \"edge-1\",\n      source: \"node-1\",\n      target: \"node-2\",\n      sourceHandle: \"output-4\",\n      animated: true,\n  },\n  {\n      id: \"edge-3\",\n      source: \"node-1\",\n      target: \"node-3\",\n      sourceHandle: \"output-1\",\n      targetHandle: \"input-1\",\n      type: 'path',\n      data: { n_source: \"1\", n_target: \"3\", h_output: \"1\", h_input: \"1\", color: \"#f1ed00\", class: \"story-1\"},\n      deletable: true,\n  },\n  {\n      id: \"edge-4\",\n      source: \"node-1\",\n      target: \"node-4\",\n      sourceHandle: \"output-2\",\n      targetHandle: \"input-1\",\n      deletable: true,\n      label: \"storyline 2\",\n      labelStyle: {fill: \"white\"},\n      labelBgStyle: {fill: \"#2b2b2b\"},\n  },*/\n];\n\n// we define the nodeTypes outside of the component to prevent re-renderings\n// you could also use useMemo inside the component\nconst nodeTypes = {\n  boxNode: BoxNode,\n  simple: SimpleNode\n};\nconst edgeTypes = {\n  path: Path\n};\nfunction NodesCanvas() {\n  _s();\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  /**\n   * Called after end of edge gets dragged to another source or target\n   * @type {function(*=, *=): void}\n   */\n  const onEdgeUpdate = useCallback((oldEdge, newConnection) => {\n    //TODO: create a method to return nodeTarget, inputHandle, sourcetarget, outputHandle\n\n    //reset the color\n    let nodeTarget = document.querySelector('[data-id=\"' + oldEdge.target + '\"]');\n    let inputHandle = nodeTarget.querySelector('[data-handleid=\"' + oldEdge.targetHandle + '\"]');\n    inputHandle.classList.add(\"empty\");\n    //if the new connection is not empty\n    nodeTarget = document.querySelector('[data-id=\"' + newConnection.target + '\"]');\n    inputHandle = nodeTarget.querySelector('[data-handleid=\"' + newConnection.targetHandle + '\"]');\n    if (inputHandle.classList.contains(\"empty\")) {\n      //connect\n    }\n\n    //get path color\n    let nodeSource = document.querySelector('[data-id=\"' + newConnection.source + '\"]');\n    let outputHandle = nodeSource.querySelector('[data-handleid=\"' + newConnection.sourceHandle + '\"]');\n    inputHandle.classList.remove(\"empty\");\n    inputHandle.style.background = outputHandle.style.background;\n    setEdges(els => updateEdge(oldEdge, newConnection, els));\n  }, []);\n  /**\n     * Called when user starts to drag connection line.\n     * We need to assign a color that correspond to the input color, when available.\n     * On the very first node the color is assigned randomly.\n     * @type {(function(*=): void)|*}\n     */\n  const onConnectStart = useCallback(params => {\n    //get an available color from the node\n    params.target.style.background = \"#1ab41e\";\n  }, []);\n  const onConnectEnd = useCallback(params => {\n    //params.target.style.background = \"#1ab41e\"\n  }, []);\n\n  /**\n   *Called when user connects two nodes\n   * @type {function(*=): void}\n   */\n  const onConnect = useCallback(params => {\n    const nodeSource = document.querySelector('[data-id=\"' + params.source + '\"]');\n    const nodeTarget = document.querySelector('[data-id=\"' + params.target + '\"]');\n    let outputHandle = nodeSource.querySelector('[data-handleid=\"' + params.sourceHandle + '\"]');\n    let inputHandle = nodeTarget.querySelector('[data-handleid=\"' + params.targetHandle + '\"]');\n    inputHandle.style.background = outputHandle.style.background;\n    setEdges(els => addEdge(params, els));\n    //finding the path to assign the color\n    //data-testid=\"rf__edge-reactflow__edge-node-1output-3-node-4input-3\n    //var path = document.querySelector('[data-testid=\"rf__edge-reactflow__edge-'+params.source+params.sourceHandle+params.target+params.targetHandle+'\"]');\n  }, []);\n  const onDragOver = useCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'move';\n  }, []);\n\n  /**\n   * Called, when the node is clicked – do something\n   * @type {(function(): void)|*}\n   */\n  const onNodeClick = useCallback(() => {}, []);\n\n  /**\n   * Called when nodes get deleted. The handles are updated. The narrative trajectory is broken.\n   May be we need to highlight the nodes to indicate the broken linkage\n   * @type {(function(): void)|*}\n   */\n  const onNodesDelete = useCallback(() => {}, []);\n  /**\n   * Called when user clicks an edge. The storyline can be rendered in the presentation editor\n   * @type {(function())|*}\n   */\n  const onEdgeClick = useCallback(() => {}, []);\n  return /*#__PURE__*/_jsxDEV(ReactFlow, {\n    nodes: nodes,\n    edges: edges,\n    onNodesChange: onNodesChange,\n    nodeTypes: nodeTypes,\n    snapToGrid: true,\n    fitView: true\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 232,\n    columnNumber: 9\n  }, this);\n}\n_s(NodesCanvas, \"JuuahgYfA+pqq3neXpkNo7PkOGc=\", false, function () {\n  return [useNodesState, useEdgesState];\n});\n_c = NodesCanvas;\nexport default NodesCanvas;\nvar _c;\n$RefreshReg$(_c, \"NodesCanvas\");","map":{"version":3,"names":["useState","useRef","useCallback","ReactFlow","useNodesState","useEdgesState","Controls","updateEdge","addEdge","ReactFlowProvider","BoxNode","SimpleNode","Path","Sidebar","initialNodes","id","type","position","x","y","data","title","targetPosition","label","className","parentNode","initialEdges","nodeTypes","boxNode","simple","edgeTypes","path","NodesCanvas","nodes","setNodes","onNodesChange","edges","setEdges","onEdgesChange","onEdgeUpdate","oldEdge","newConnection","nodeTarget","document","querySelector","target","inputHandle","targetHandle","classList","add","contains","nodeSource","source","outputHandle","sourceHandle","remove","style","background","els","onConnectStart","params","onConnectEnd","onConnect","onDragOver","event","preventDefault","dataTransfer","dropEffect","onNodeClick","onNodesDelete","onEdgeClick"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/dashboard-onboarding-ui/src/components/nodesCanvas/index.jsx"],"sourcesContent":["import {useState, useRef, useCallback} from \"react\";\n\nimport ReactFlow, {\n    useNodesState, useEdgesState, Controls, updateEdge, addEdge, ReactFlowProvider,\n} from \"reactflow\";\n\nimport \"reactflow/dist/style.css\";\nimport \"../../assets/css/flow.scss\";\n\n// Node types\nimport BoxNode from \"./nodeTypes/boxNode\";\nimport SimpleNode from \"./nodeTypes/simpleNode\";\n//Custom edge\nimport Path from \"./path\";\n\nimport Sidebar from '../dashboard/index';\n\nconst initialNodes = [\n    {\n        id: \"node-1\",\n        type: \"simple\",\n        position: {x: 0, y: 70},\n        data: {title: \"Dashboard\", type: \"dashboard\"},\n    },\n    {\n        id: \"node-2\",\n        type: \"simple\",\n        targetPosition: \"top\",\n        position: {x: 120, y: 70},\n        data: {title: \"Line Chart\", type: \"line-chart\"},\n    },\n    {\n        id: 'node-3',\n        data: { label: 'OR' },\n        position: { x: 240, y: 0 },\n        className: 'node-group',\n    },\n    {\n        id: \"node-4\",\n        type: \"simple\",\n        targetPosition: \"top\",\n        position: {x: 30, y: 40},\n        data: {title: \"Bar chart\", type: \"bar-chart\"},\n        parentNode: 'node-3',\n    },\n    {\n        id: \"node-5\",\n        type: \"simple\",\n        targetPosition: \"top\",\n        position: {x: 140, y: 40},\n        data: {title: \"Bar chart\", type: \"bar-chart\"},\n        parentNode: 'node-3',\n    },\n    {\n        id: \"node-6\",\n        type: \"simple\",\n        targetPosition: \"top\",\n        position: {x: 30, y: 110},\n        data: {title: \"Dashboard\", type: \"dashboard\"},\n        parentNode: 'node-3',\n    },\n    {\n        id: \"node-7\",\n        type: \"simple\",\n        targetPosition: \"top\",\n        position: {x: 140, y: 110},\n        data: {title: \"Line chart\", type: \"line-chart\"},\n        parentNode: 'node-3',\n    },\n\n];\n/** Create edges between nodes if needed*/\nconst initialEdges = [\n    /*{\n        id: \"edge-1\",\n        source: \"node-1\",\n        target: \"node-2\",\n        sourceHandle: \"output-4\",\n        animated: true,\n    },\n    {\n        id: \"edge-3\",\n        source: \"node-1\",\n        target: \"node-3\",\n        sourceHandle: \"output-1\",\n        targetHandle: \"input-1\",\n        type: 'path',\n        data: { n_source: \"1\", n_target: \"3\", h_output: \"1\", h_input: \"1\", color: \"#f1ed00\", class: \"story-1\"},\n        deletable: true,\n    },\n    {\n        id: \"edge-4\",\n        source: \"node-1\",\n        target: \"node-4\",\n        sourceHandle: \"output-2\",\n        targetHandle: \"input-1\",\n        deletable: true,\n        label: \"storyline 2\",\n        labelStyle: {fill: \"white\"},\n        labelBgStyle: {fill: \"#2b2b2b\"},\n    },*/\n];\n\n\n// we define the nodeTypes outside of the component to prevent re-renderings\n// you could also use useMemo inside the component\nconst nodeTypes = {boxNode: BoxNode, simple: SimpleNode};\nconst edgeTypes = {\n    path: Path,\n};\n\nfunction NodesCanvas() {\n    const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n    const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n    /**\n     * Called after end of edge gets dragged to another source or target\n     * @type {function(*=, *=): void}\n     */\n    const onEdgeUpdate = useCallback(\n        (oldEdge, newConnection) => {\n\n            //TODO: create a method to return nodeTarget, inputHandle, sourcetarget, outputHandle\n\n            //reset the color\n            let nodeTarget = document.querySelector('[data-id=\"'+oldEdge.target+'\"]');\n            let inputHandle = nodeTarget.querySelector('[data-handleid=\"'+oldEdge.targetHandle+'\"]');\n            inputHandle.classList.add(\"empty\");\n            //if the new connection is not empty\n            nodeTarget = document.querySelector('[data-id=\"'+newConnection.target+'\"]');\n            inputHandle = nodeTarget.querySelector('[data-handleid=\"'+newConnection.targetHandle+'\"]');\n\n            if(inputHandle.classList.contains(\"empty\")){\n                //connect\n            }\n\n            //get path color\n            let nodeSource = document.querySelector('[data-id=\"'+newConnection.source+'\"]');\n            let outputHandle = nodeSource.querySelector('[data-handleid=\"'+newConnection.sourceHandle+'\"]');\n            inputHandle.classList.remove(\"empty\");\n            inputHandle.style.background=outputHandle.style.background;\n\n\n            setEdges((els) => updateEdge(oldEdge, newConnection, els))},\n        []\n    );\n  /**\n     * Called when user starts to drag connection line.\n     * We need to assign a color that correspond to the input color, when available.\n     * On the very first node the color is assigned randomly.\n     * @type {(function(*=): void)|*}\n     */\n    const onConnectStart = useCallback(\n        (params) => {\n            //get an available color from the node\n            params.target.style.background = \"#1ab41e\";\n\n        },\n        [],\n    );\n\n    const onConnectEnd = useCallback(\n        (params) => {\n            //params.target.style.background = \"#1ab41e\"\n\n        },\n        [],\n    );\n\n\n    /**\n     *Called when user connects two nodes\n     * @type {function(*=): void}\n     */\n    const onConnect = useCallback((params) => {\n\n        const nodeSource = document.querySelector('[data-id=\"'+params.source+'\"]');\n        const nodeTarget = document.querySelector('[data-id=\"'+params.target+'\"]');\n        let outputHandle = nodeSource.querySelector('[data-handleid=\"'+params.sourceHandle+'\"]');\n        let inputHandle = nodeTarget.querySelector('[data-handleid=\"'+params.targetHandle+'\"]');\n        inputHandle.style.background = outputHandle.style.background;\n        setEdges((els) => addEdge(params, els))\n        //finding the path to assign the color\n        //data-testid=\"rf__edge-reactflow__edge-node-1output-3-node-4input-3\n        //var path = document.querySelector('[data-testid=\"rf__edge-reactflow__edge-'+params.source+params.sourceHandle+params.target+params.targetHandle+'\"]');\n\n    }, []);\n\n    const onDragOver = useCallback((event) => {\n        event.preventDefault();\n        event.dataTransfer.dropEffect = 'move';\n    }, []);\n\n\n\n\n\n    /**\n     * Called, when the node is clicked – do something\n     * @type {(function(): void)|*}\n     */\n    const onNodeClick = useCallback(\n        () => {\n        },\n        [],\n    );\n\n\n    /**\n     * Called when nodes get deleted. The handles are updated. The narrative trajectory is broken.\n     May be we need to highlight the nodes to indicate the broken linkage\n     * @type {(function(): void)|*}\n     */\n    const onNodesDelete = useCallback(\n        () => {\n\n        },\n        [],\n    );\n    /**\n     * Called when user clicks an edge. The storyline can be rendered in the presentation editor\n     * @type {(function())|*}\n     */\n    const onEdgeClick = useCallback(\n        () => {\n\n        },\n        [],\n    );\n\n\n    return (\n        <ReactFlow\n            nodes={nodes}\n            edges={edges}\n            onNodesChange={onNodesChange}\n            nodeTypes={nodeTypes}\n            snapToGrid\n            fitView\n        />\n    );\n}\n\nexport default NodesCanvas;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}